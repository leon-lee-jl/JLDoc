*******************************
GNU Make Documentation
*******************************
*By Richard M. Stallman, Roland McGrath, Paul D. Smith*

.. contents:: Table of Contents
   :depth: 4

Chapter 1. Overview of make
===========================
To prepare to use make, you must write a file called the makefile that describes the relationships among files in your program and provides commands for updating each file.

The make program uses the makefile data base and the last-modification times of the files to decide which of the files need to be updated.

Main Operators:

* **$@**: the target file
* **$^**: all dependencies, without repetition
* **$+**: all dependencies, with repetition
* **$<**: the first dependency
* **:=**: substitute former value of the variable
* **:?**: set the value of the variable if not set before
* **+=**: append the value to the variable

The variables $$? and $$* are not available and expand to the empty string. But for static pattern rules the $$* variable is set to the pattern stem.

Chapter 2. An Introduction to Makefiles
=======================================
A simple makefile consists of “rules” with the following shape:
.. code-block:: makefile

    target ... : prerequisites ...
        recipe
        ...
        ...
* A target is usually the name of a file that is generated by a program; examples of targets are executable or object files.
* A prerequisite is a file that is used as input to create the target.
* A recipe is an action that make carries out.

.. warning:: you need to put a tab character at the beginning of every recipe line! If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character

Targets that do not refer to files but are just actions are called phony targets. By default, make starts with the first target (not targets whose names start with ‘.’). You can change it by modifying the .DEFAULT_GOAL special variable. It is standard practice for every makefile to have a variable named objects, OBJECTS, objs, OBJS, obj, or OBJ which is a list of all object file names.

It is not necessary to spell out the recipes for compiling the individual C source files, because make can figure them out: it has an implicit rule for updating a ‘.o’ file from a correspondingly named ‘.c’ file using a ‘cc -c’ command.

".PHONY : clean", this prevents make from getting confused by an actual file called clean and causes it to continue in spite of errors from rm.

Chapter 3. Writing Makefiles
============================
Makefiles contain five kinds of things:

* Explict rules: says when and how to remake one or more files, called the rule’s targets.
* Implicit rules: says when and how to remake a class of files based on their names.
* Variable definitions: a line that specifies a text string value for a variable that can be substituted into the text later.
* Directives: an instruction for make to do something special while reading the makefile, including reading another makefile, deciding whether to use or ignore a part of the makefile, and defining a variable from a verbatim string containing multiple lines.
* Comments: ‘#’ in a line of a makefile starts a comment.

Outside of recipe lines, backslash/newlines are converted into a single space character. If the .POSIX special target is defined then backslash/newline handling is modified slightly to conform to POSIX.2: first, whitespace preceding a backslash is not removed and second, consecutive backslash/newlines are not condensed.

By default, when make looks for the makefile, it tries the following names, in order: GNUmakefile, makefile and Makefile.

**"include filenames..."**: for including other makefiles, but no tab before this command. If the specified name does not start with a slash, and the file is not found in the current directory, several other directories are searched. First, any directories you have specified with the ‘-I’ or ‘--include-dir’ option are searched. Then the following directories (if they exist) are searched, in this order: prefix/include (normally /usr/local/include 1 ) /usr/gnu/include, /usr/local/include, /usr/include. For compatibility with some other make implementations, sinclude is another name for -include.

If the environment variable MAKEFILES is defined, make considers its value as a list of names (separated by whitespace) of additional makefiles to be read before the others. ‘%’ match any target.

GNU make does its work in two distinct phases. During the first phase it reads all the make- files, included makefiles, etc. and internalizes all the variables and their values, implicit and explicit rules, and constructs a dependency graph of all the targets and their prerequisites. During the second phase, make uses these internal structures to determine what targets will need to be rebuilt and to invoke the rules necessary to do so.

That is, the target and prerequisite sections are expanded immediately, and the recipe used to construct the target is always deferred. This general rule is true for explicit rules, pattern rules, suffix rules, static pattern rules, and simple prerequisite definitions.

In the previous section we learned that GNU make works in two distinct phases: a read-in phase and a target-update phase. GNU make also has the ability to enable a second expansion of the prerequisites (only) for some or all targets defined in the makefile. In order for this second expansion to occur, the special target .SECONDEXPANSION must be defined before the first prerequisite list that makes use of this feature.

Chapter 4. Wiring Rules
=======================
The order of rules is not significant, except for determining the default goal: the target for make to consider, if you do not otherwise specify one. The default goal is the target of the first rule in the first makefile. If the first rule has multiple targets, only the first target is taken as the default. There are two exceptions: a target starting with a period is not a default unless it contains one or more slashes, ‘/’, as well; and, a target that defines a pattern rule has no effect on the default goal.

In general, a rule looks like this:

.. code-block:: shell

    targets : prerequisites
            recipe
            ...

or like this:

.. code-block:: shell

    targets : prerequisites ; recipe
            recipe
            ...

Because dollar signs are used to start make variable references, if you really want a dollar sign in a target or prerequisite you must write two of them, ‘$$’. If you have enabled secondary expansion and you want a literal dollar sign in the prerequisites list, you must actually write four dollar signs (‘$$$$’).

Two different types of prerequisites understood by GNU make:

1. Normal prerequisites: imposes an order in which recipes will be invoked, and imposes a dependency relationship
2. Order-only prerequisites: impose a specific ordering on the rules to be invoked without forcing the target to be updated. "targets : normal-prerequisites | order-only-prerequisites"

If you declare the same file to be both a normal and an order-only prerequisite, the normal prerequisite takes precedence (since they have a strict superset of the behavior of an order-only prerequisite).

4.3 Using Wildcard Characters in File Names
-------------------------------------------
* .c specifies a list of all the files (in the working directory) whose names end in ‘.c’.
* ~/bin expands to /home/you/bin. ~john/bin expands to /home/john/bin.
* Wildcard expansion does not happen when you define a variable.

If you use the value of objects in a target or prerequisite, wildcard expansion will take place there. If you use the value of objects in a recipe, the shell may perform wildcard expansion when the recipe runs. To set objects to the expansion, instead use: **objects := $(wildcard *.o)**

4.4 Searching Directories for Prerequisites
-------------------------------------------
The value of the make variable VPATH specifies a list of directories that make should search. Most often, the directories are expected to contain prerequisite files that are not in the current directory; however, make uses VPATH as a search list for both prerequisites and targets of rules.

Similar to the VPATH variable, but more selective, is the vpath directive (note lower case), which allows you to specify a search path for a particular class of file names: those that match a particular pattern.

If an out-of-date target is found by directory search in a directory that also appears in GPATH, then that pathname is not thrown away. The target is rebuilt using the expanded path.

When a prerequisite’s name has the form ‘-lname’, make handles it specially by searching for the file libname.so, and, if it is not found, for the file libname.a in the current directory, in directories specified by matching vpath search paths and the VPATH search path, and then in the directories /lib, /usr/lib, and prefix/lib. Seach path can be customizable via the .LIBPATTERNS variable

4.5 Phony Targets
-----------------
A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request.

4.6 Rules without Recipes or Prerequisites
------------------------------------------
If a rule has no prerequisites or recipe, and the target of the rule is a nonexistent file, then make imagines this target to have been updated whenever its rule is run. This implies that all targets depending on this one will always have their recipe run.

4.8 Special Built-in Target Names
---------------------------------

1. **.PHONY**: The prerequisites of the special target .PHONY are considered to be phony tar- gets.
2. **.SUFFIXES**: The prerequisites of the special target .SUFFIXES are the list of suffixes to be used in checking for suffix rules.
3. **.DEFAULT**: The recipe specified for .DEFAULT is used for any target for which no rules are found (either explicit rules or implicit rules).
4. **.PRECIOUS**: If make is killed or interrupted during the execution of their recipes, the target is not deleted.
5. **.INTERMEDIATE**: The targets which .INTERMEDIATE depends on are treated as intermediate files.
6. **.SECONDARY**: The targets which .SECONDARY depends on are treated as intermediate files, except that they are never automatically deleted.
7. **.SECONDEXPANSION**: All prerequisite lists defined after it appears will be expanded a second time after all makefiles have been read in.
8. **.DELETE_ON_ERROR**: Make will delete the target of a rule if it has changed and its recipe exits with a nonzero exit status.
9. **.IGNORE**: Make will ignore errors in execution of the recipe for those particular files.
10. **.LOW_RESOLUTION_TIME**: Make assumes that these files are created by commands that generate low resolution time stamps.
11. **.SILENT**: Make will not print the recipe used to remake those particular files before executing them.
12. **.EXPORT_ALL_VARIABLES**: Export all variables to child processes by default.
13. **.NOTPARALLEL**: Make will be run serially, even if the ‘-j’ option is given.
14. **.ONESHELL**: Recipe will be given to a single invocation of the shell rather than each line being invoked separately.
15. **.POSIX**: Makefile will be parsed and run in POSIX-conforming mode.

4.10 Multiple Rules for One Target
----------------------------------
There can only be one recipe to be executed for a file. If more than one rule gives a recipe for the same file, make uses the last one given and prints an error message.

4.11 Static Pattern Rules
-------------------------
Static pattern rules are rules which specify multiple targets and construct the prerequisite names for each target based on the target name.

Syntax of Static Pattern Rules:
.. code-block:: shell

    targets ...: target-pattern: prereq-patterns ...
               recipe
               ...

4.12 Double-Colon Rules
-----------------------
Double-colon rules (with :: instead of :) with the same target are in fact completely separate from one another. Each double-colon rule is processed individually, just as rules with different targets are processed.


4.13 Generating Prerequisites Automatically
-------------------------------------------
Modern compiler can generate make prerequisite automatically, use option -M in cc it will output the makefile rule.

The practice we recommend for automatic prerequisite generation is to have one makefile corresponding to each source file. For each source file name.c there is a makefile name.d which lists what files the object file name.o depends on. That way only the source files that have changed need to be rescanned to produce the new prerequisites.

Chapter 5. Writing Recipes in Rules
===================================
5.1 Recipe Syntax
-----------------
Recipe is in shell syntax (/bin/sh as default), and all statements in recipe area will be passed to shell. If you want a dollar sign to appear in your recipe, you must double it (‘$$’).

5.2 Recipe Echoing
------------------
When a line starts with ‘@’, the echoing of that line is suppressed.

5.3 Recipe Execution
--------------------
Setting shell variables and invoking shell commands such as cd that set a context local to each process will not affect the following lines in the recipe.

If the .ONESHELL special target appears anywhere in the makefile then all recipe lines for each target will be provided to a single invocation of the shell. If the .ONESHELL special target appears anywhere in the makefile then all recipe lines for each target will be provided to a single invocation of the shell.

The program used as the shell is taken from the variable SHELL. The argument(s) passed to the shell are taken from the variable .SHELLFLAGS.

5.4 Parallel Execution
----------------------
The ‘-j’ or ‘--jobs’ option tells make to execute many recipes simultaneously. You can use the ‘-l’ option to tell make to limit the number of jobs to run at once, based on the load average. The ‘-l’ or ‘--max-load’ option is followed by a floating-point number.

Use the ‘--output-sync’ (‘-O’) option to make outputs of several jobs more readable, including for modes, none, line, target(default), and recurse. The ‘line’ mode can be useful for front-ends that are watching the output of make to track when recipes are started and completed.

For multiple inputs, make will invalidate the standard input streams of all but one running recipe.

5.5 Errors in Recipes
---------------------
To ignore errors in a recipe line, write a ‘-’ at the beginning of the line’s text (after the initial tab).

5.6 Interrupting or Killing make
--------------------------------
If make gets a fatal signal while a shell is executing, it may delete the target file that the recipe was supposed to update.

5.7 Recursive Use of make
-------------------------
Recursive use of make means using make as a command in a makefile. This technique is useful when you want separate makefiles for various subsystems that compose a larger system.

Recursive make commands should always use the variable MAKE, not the explicit command name ‘make’.

Variable values of the top-level make can be passed to the sub-make through the environment by explicit request. To pass down, or export, a variable, make adds the variable and its value to the envi- ronment for running each line of the recipe. The sub-make, in turn, uses the environment to initialize its table of variable values. If you want to export specific variables to a sub-make, use the export directive, like this:
.. code-block:: shell

    export variable ...

If you want to prevent a variable from being exported, use the unexport directive, like this:
.. code-block:: shell

    unexport variable ...

The last export or unexport directive that appears by itself determines the behavior for the entire run of make. The main use of MAKELEVEL is to test it in a conditional directive; this way you can write a makefile that behaves one way if run recursively and another way if run directly by you.

Flags such as ‘-s’ and ‘-k’ are passed automatically to the sub-make through the variable MAKEFLAGS.

If you use several levels of recursive make invocations, the ‘-w’ or ‘--print-directory’ option can make the output a lot easier to understand by showing each directory as make starts processing it and as make finishes processing it.

5.8 Defining Canned Recipes
---------------------------
When the same sequence of commands is useful in making various targets, you can define it as a canned sequence with the define directive, and refer to the canned sequence from the recipes for those targets.
.. code-block:: shell

    define run-yacc = yacc
    $(firstword $^)
    mv y.tab.c $@
    endef

5.9 Using Empty Recipes
-----------------------
"target: ;", to prevent a target from getting implicit recipes (from implicit rules or the .DEFAULT special target;)
